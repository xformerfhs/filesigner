# Concept

## Description

This document describes the concept.

## Motivation

There have been and continue to be attacks on companies and individuals in which manipulated programs or files have been used.
In recent years, it has become generally accepted that such manipulations must be recognized in order to increase the security of all.

The [Open Source Security Foundation](https://openssf.org/) has launched many projects to increase the security of open source projects.
One of these is the [Scorecard](https://github.com/ossf/scorecard/tree/main) project, which requires artifacts to be digitally signed.

The [SigStore](https://www.sigstore.dev/) project[^1] establishes a method and an infrastructure that can be used to check at any time whether a container image is actually the one published by the creator.

[^1]: SigStore uses similar methods.
  This project was developed from 2021 to 2024 without knowledge of the SigStore project.

The [NIST](https://www.nist.gov) has published the "Secure Software Development Framework (SSDF)" in the standard [SP 800-218](https://csrc.nist.gov/pubs/sp/800/218/final), where the measure "PS 2.1" requires that the creator of software must provide information that allows the user to verify the integrity of the software artifacts.

However, it is not only important for program artefacts such as programs, libraries or configuration files to check whether the data is unchanged.
This is also necessary for many other types of data, such as images, documents and any other data.

## Background

An integrity check is generated by the interaction of two components:

1. A checksum ([hash](https://en.wikipedia.org/wiki/Cryptographic_hash_function)) is calculated over the data.
2. The checksum is encrypted with the private key of an [asymmetric encryption method](https://en.wikipedia.org/wiki/Public-key_cryptography).

This value is called a [digital signature](https://en.wikipedia.org/wiki/Digital_signature).

To verify the signature, the following three steps must be carried out:

1. Calculate the checksum (hash) of the local copy of the data.
2. Decrypt the digital signature using the public key associated with the private key.
3. Comparison of the locally calculated checksum with the decrypted checksum.

If both checksums are the same, the digital signature is valid.

This procedure ensures that

1. The data has not been altered
2. The creator of the digital signature was in possession of the private key belonging to the public key.

To ensure that the public key used to verify the digital signature is actually the one it claims to be, there are [certificates](https://de.wikipedia.org/wiki/Digitales_Zertifikat).
In this certificate, a trustworthy authority attests that the public key belongs to a specific entity.
This can be an e-mail address or a website or a person or company.

## Difficulties with the certificate system

Unfortunately, certificates have many problems:

- The certificate's private key must be permanently stored and **very well** secured.
    - Anyone who gets hold of the private key can sign artifacts on behalf of the owner of the certificate.
    - It is very difficult to secure the private key well and usually very expensive, as it requires the use of special hardware ([HSM](https://de.wikipedia.org/wiki/Hardware-Sicherheitsmodul)).
- False or erroneous issuance.
- They can be withdrawn.
    - It is tedious and error-prone to check for withdrawn certificates.
- They have an end date after which they are no longer valid.

The last point in particular leads to enormous problems:

- Expired certificates cause total IT process failures.
- When you receive a signed e-mail, the certificate associated with the signature has a limited validity.Almost all email programmers make the mistake of displaying the signature of an email as "invalid" if the associated certificate has expired.
In fact, the signature is valid because the certificate was valid at the time of the digital signature.Programmers and operators are often overwhelmed with the correct handling of certificates.## Solution approach

The signature system presented here avoids the two biggest weaknesses of certificates:

1. Expiration date
2. Permanent storage of the private key

On the one hand, the solution presented here was inspired by the encryption software [age](https://github.com/FiloSottile/age) by encryption expert Filippo Valsorda.In age there are no certificates that expire.The public key is published and is valid for as long as it is published.This eliminates the first weak point.The second idea comes from my esteemed colleague Florian Schäfer from DB Systel GmbH:
The private key is **not** stored after signing.
This means that it can no longer be stolen or misused.

The public key is published and is valid for as long as it is published.

This solves the first weak point.

The second idea comes from my esteemed colleague Florian Schäfer of DB Systel GmbH:
The private key is **not** stored after signing.
This means that it can no longer be stolen or misused.
Only the public key of a specific signing process is published in a trustworthy location.
It can be used to verify a signature.

The SigStore project uses the same procedure.
There also a short-lived key pair is [generated](https://docs.sigstore.dev/signing/overview/#verifying-identity-and-signing-the-artifact) and the private key is deleted immediately after signing.
Only the public key is retained to enable verification of the signature.
With SigStore, the result is stored in a "transparency log", which is nothing other than a trustworthy storage location for the signature result.

This procedure here does not specify a storage location.

The following information is published for each signing process:

1. The public key
2. A context ID
3. The timestamp of the signing process
4. The computer name on which the signing process was carried out

These four pieces of information must be published in a trustworthy location.

The context ID provides more information about the purpose of the signatures.
This can be a build number, version information, an identifier for the target or source environment.
It is an arbitrary free text field.

All this information is used to create the signature.

The signatures of the files are collected in one file.
This file is signed, as well.

If someone now receives the artifacts, they can use the signature file to check the signatures of all files.

In this repository, such a procedure has been implemented in [Go](https://go.dev/).

It can also be implemented in any other programming language.
The format of the signature file is described in [file_format.md](file_format.md).
The technical specification of the values contained therein is described in [technical_specification.md](technical_specification.md).
